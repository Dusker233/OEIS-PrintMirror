{
    "number": 361720,
    "data": "1,1,2,4,12,37,164,849,6081,56164,698921",
    "name": "Number of nonisomorphic right involutory P\u0142onka magmas with n elements.",
    "comment": [
        "Alexandrul Chirvasitu and Gigel Militaru introduced the notion of a right P\u0142onka magma as a magma X that satisfies (xy)z = (xz)y and x(yz) = xy for all x,y,z in X. It is called involutory, if it satisfies the additional property (xy)y = x for all x,y in X.",
        "A right P\u0142onka magma (X,*) is associative if and only if there exists an idempotent self-map f = f^2: X -> X such that x*y = f(x) for all x,y in X (the rows of the corresponding Cayley table must necessarily be constant). Thus the total number of associative right P\u0142onka magmas on a given set of n elements is A000248 with A000041 as the corresponding number of isomorphism classes."
    ],
    "reference": [
        "J. P\u0142onka, \"On k-cyclic groupoids\", Math. Japon. 30 (3), 371-382 (1985)."
    ],
    "link": [
        "A. Chirvasitu and G. Militaru, <a href=\"https://arxiv.org/abs/2305.14138\">A universal-algebra and combinatorial approach to the set-theoretic Yang-Baxter equation</a>, arXiv:2305.14138 [math.QA], 2023.",
        "Anna Romanowska and Barbara Roszkowska, <a href=\"https://doi.org/10.1515/dema-1987-1-224\">On Some Groupoid Modes</a>, Demonstratio Mathematica, vol. 20, no. 1-2, 1987, pp. 277-290."
    ],
    "program": [
        "(Sage)",
        "def right_involutory_plonka(n):",
        "    G = Integers(n)",
        "    Perm = SymmetricGroup(list(G))",
        "    M = [sigma for sigma in Perm if sigma == ~sigma]",
        "    def is_compatible(r):",
        "        return all([ r[i]*r[j] == r[j]*r[i] and r[r[i](j)] == r[j] for i in range(len(r)) for j in range(len(r)) if ZZ(r[i](j)) < len(r) ])",
        "    def possible_extensions(r):",
        "        R = []",
        "        for m in M:",
        "            r_new = r+[m]",
        "            if is_compatible(r_new):",
        "                R += [r_new]",
        "        return R",
        "    def extend(R):",
        "        R_new = []",
        "        for r in R:",
        "            R_new += possible_extensions(r)",
        "        return R_new",
        "    i = 0",
        "    R = [[]]",
        "    while i < n:",
        "        R = extend(R)",
        "        i += 1",
        "    act = lambda sigma,r: [(~sigma)*r[(~sigma)(i)]*sigma for i in range(len(r))]    # In Sage, the composition of permutations is reversed.",
        "    orbits = []",
        "    while R:",
        "        r = R.pop()",
        "        orb = []",
        "        for sigma in Perm:",
        "            orb += [tuple(act(sigma,r))]",
        "            try: R.remove(act(sigma,r))",
        "            except: pass",
        "        orbits += [set(orb)]",
        "    return len(orbits)",
        "(Sage)",
        "def right_involutory_plonka(n):",
        "    N = range(n)",
        "    Perm = SymmetricGroup(N)",
        "    M = [sigma for sigma in Perm if sigma == ~sigma]",
        "    def is_compatible(r,r_new):",
        "        length = len(r)",
        "        inds = range(length)",
        "        for i in inds:",
        "            if not r[i]*r_new == r_new*r[i]:",
        "                return [false]",
        "        for i in inds:",
        "            rni = r_new(i)",
        "            if i < rni < length:",
        "                if not r[rni] == r[i]:",
        "                    return [false]",
        "            if rni == length:",
        "                if not r_new == r[i]:",
        "                    return [false]",
        "        for i in inds:",
        "            for j in inds:",
        "                if r[i](j) == length:",
        "                    if not r_new == r[j]:",
        "                        return [false]",
        "        return true, r+[r_new]",
        "    def possible_extensions(r):",
        "        R = []",
        "        for m in M:",
        "            r_potential = is_compatible(r,m)",
        "            if r_potential[0]:",
        "                R += [r_potential[1]]",
        "        return R",
        "    def extend(R):",
        "        R_new = []",
        "        for r in R:",
        "            R_new += possible_extensions(r)",
        "        return R_new",
        "    R = [[]]",
        "    for i in N:",
        "        R = extend(R)",
        "    act = lambda sigma,r: [(~sigma)*r[(~sigma)(i)]*sigma for i in range(n)]    # In Sage, the composition of permutations is reversed.",
        "    orbits = []",
        "    while R:",
        "        r = R.pop()",
        "        orb = []",
        "        for sigma in Perm:",
        "            r_iso = act(sigma,r)",
        "            orb += [tuple(r_iso)]",
        "            try: R.remove(r_iso)",
        "            except: pass",
        "        orbits += [set(orb)]",
        "    return len(orbits)"
    ],
    "xref": [
        "A362821 is the labeled version.",
        "Cf. A001329 (magmas), A000041, A362382, A362385, A362642, A362822."
    ],
    "keyword": "nonn,hard,more",
    "offset": "0,3",
    "author": "_Philip Turecek_, Apr 14 2023",
    "ext": [
        "a(8)-a(10) from _Andrew Howroyd_, Apr 17 2023"
    ],
    "references": 5,
    "revision": 66,
    "time": "2023-05-27T22:38:41-04:00",
    "created": "2023-05-13T06:20:07-04:00"
}