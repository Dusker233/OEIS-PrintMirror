{
    "number": 346071,
    "data": "6,18,54,87,108,174,174,324,324,324,492,492,492,984,984,1296,1296,1296,1440,1440,2592,2592,2592,2592,3960,3960,3960,3960,4320,4320,4320,5760,5940,5940,5940,5940,5940,5940,8640,9900,9900,9900,11880,11880,11880,11880,11880",
    "name": "a(n) is the smallest number m such that m^3 = x^3 + y^3 + z^3, x > y > z > 0, has at least n different solutions.",
    "comment": [
        "a(n) is the smallest number for which there are at least n sets of positive integers (b_i, c_i, d_i) i=1..n which satisfy the equation a(n)^3 = b_i^3 + c_i^3 + d_i^3.",
        "This sequence is related to Euler's sum of powers conjecture. In particular to the case k=3, a(n) is the smallest number that has at least n different solutions to the equation.",
        "The sequences of numbers whose cubes can be expressed as the sum of 3 positive cubes in at least n ways for n = 1, 2, 3, ... form a family of related sequences. This sequence is the sequence of first terms in that family of sequences.",
        "The first of this family is A023042."
    ],
    "link": [
        "Wikipedia, <a href=\"https://en.wikipedia.org/wiki/Euler%27s_sum_of_powers_conjecture\">Euler's sum of powers conjecture</a>"
    ],
    "example": [
        "a(1) = 6 because 6^3 = 5^3 + 4^3 + 3^3; 6 = a(1) = A023042(1).",
        "a(2) = 18 because 18^3 = 15^3 + 12^3 + 9^3 = 16^3 + 12^3 + 2^3.",
        "a(3) = 54 because 54^3 = 45^3 + 36^3 + 27^3 = 48^3 + 36^3 + 6^3 = 53^3 + 19^3 + 12^3."
    ],
    "program": [
        "(Python)",
        "import numpy as np",
        "def residual(a,b,c,d, exp=3):",
        "    return a**exp-b**exp-c**exp-d**exp",
        "def test(max_n,k=3):",
        "    ans=dict()",
        "    for a in range(max_n):",
        "        #print(a)",
        "        for b in range(int(np.ceil((a**k/3)**(1/k))),a):",
        "            n3=a**k-b**k",
        "            for c in range(int(np.ceil((n3/2)**(1/k))),b):",
        "                m3=n3-c**k",
        "                if m3<0:",
        "                    break;",
        "                l=int(np.ceil((m3)**(1/k)))",
        "                options=[l,l-1]",
        "                for d in options:",
        "                    res=residual(a,b,c,d, exp=k)",
        "                    if res==0:",
        "                        if a in ans.keys():",
        "                            ans[a].append((a,b,c,d))",
        "                        else:",
        "                            ans[a]=[(a,b,c,d)]",
        "                        #print(\"found:\",(a,b,c,d))",
        "                        break",
        "                    else:",
        "                        #print(\"tested: {0}, residual: {1}\".format((a,b,c,d),res))",
        "                        if res>0:",
        "                            break",
        "    return ans",
        "def serie(N):",
        "    result=test(N)",
        "    results_by_number_of_answers=[]",
        "    results_by_number_of_answers.append(result)",
        "    temp=dict()",
        "    for k in result.keys():",
        "        if len(result[k])>=2:",
        "            temp[k]=result[k]",
        "    results_by_number_of_answers.append(temp)",
        "    i=3",
        "    while len(temp)>0:",
        "        temp=dict()",
        "        for k in results_by_number_of_answers[-1].keys():",
        "            if len(results_by_number_of_answers[-1][k])>=i:",
        "                temp[k]=result[k]",
        "        if len(temp)>0:",
        "            results_by_number_of_answers.append(temp)",
        "        i+=1",
        "    return [next(iter(a)) for a in results_by_number_of_answers]",
        "#Get the elements of the serie up until A_n>1000",
        "A=serie(1000)",
        "print(A)",
        "(Python)",
        "from itertools import combinations",
        "from collections import Counter",
        "from sympy import integer_nthroot",
        "def icbrt(n): return integer_nthroot(n, 3)[0]",
        "def aupto(mmax):",
        "    cbs = [i**3 for i in range(mmax+1)]",
        "    cbsset = set(cbs)",
        "    c = Counter(sum(c) for c in combinations(cbs, 3) if sum(c) in cbsset)",
        "    nmax = max(c.values())",
        "    return [min(icbrt(s) for s in c if c[s] >= n) for n in range(1, nmax+1)]",
        "print(aupto(500)) # _Michael S. Branicky_, Sep 04 2021"
    ],
    "xref": [
        "Cf. A023042, A025418, A346137, A316359."
    ],
    "keyword": "nonn,more",
    "offset": "1,1",
    "author": "_Sebastian Magee_, Jul 30 2021",
    "ext": [
        "a(16)-a(31) from _Jinyuan Wang_, Aug 02 2021",
        "More terms from _David A. Corneth_, Sep 04 2021"
    ],
    "references": 1,
    "revision": 72,
    "time": "2021-10-05T22:43:34-04:00",
    "created": "2021-10-05T22:43:34-04:00"
}