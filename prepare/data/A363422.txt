{
    "number": 363422,
    "data": "351,621,886,5931,86673,97533,425322,430762,920781,3524751,4495491,4834872,5594151,5941971,6218001,6801381,6916671,8630841,32331001,44235301,57982563,67968432,68577483,69617484,71673981,88873491,89943354,119910901,338752611",
    "name": "Numbers k which satisfy k = concat(a,b,...) and a*b*... = reverse(k), for some two or more a,b,...",
    "comment": [
        "k > reverse(k) for all terms, sometimes narrowly, see a(28) = 119910901.",
        "This is easily shown: c=concat(a,b), c/a > (c-b)/a = 10^(#digits of b) > b; c > b*a.",
        "Follows for triple or higher concatenations by induction.",
        "Of the first 39 terms, 12 arise due to concatenations of only two numbers and are therefore also present in A281555.",
        "No terms yet found with a product of more than five numbers.",
        "Sometimes a term B relates to an earlier term A via a particular number N for which B=concat(A,N) and reverse(B)=reverse(A)*reverse(N). This is true of B=a(15), A=a(2), and N=8001 for example."
    ],
    "example": [
        "153 = 3*51.",
        "1395 = 5*9*31.",
        "1945944 = 44*9*54*91.",
        "1008126 = 6*21*8001.",
        "171548496 = 6*94*84*51*71."
    ],
    "program": [
        "(Python)",
        "# Find numbers with a de-concatenation that multiplies to their reverse.",
        "import math",
        "def digits(x):",
        "    y = []",
        "    while x>0:",
        "        y = [x%10] + y",
        "        x//=10",
        "    return y",
        "def check(x):",
        "    xx = digits(x)",
        "    if xx[0] < xx[-1]:",
        "        return",
        "    for i in range(1,2**(len(xx)-1)):",
        "        for dnum,digit in enumerate(xx):",
        "            if dnum==0:",
        "                thisProd = [xx[0]]",
        "            elif i&(2**(dnum-1)):",
        "                if digit==0:",
        "                    break",
        "                thisProd += [digit]",
        "            else:",
        "                thisProd[-1] = thisProd[-1]*10+digit",
        "        answer = math.prod(thisProd)",
        "        if not answer%10==xx[0]:",
        "            continue",
        "        if digits(answer)[-1::-1]==xx:",
        "            print('\\r'+str(thisProd).replace(', ','x')[1:-1])",
        "            return",
        "    return",
        "i=0",
        "while True:",
        "    i += 1",
        "    if not i%10000:",
        "        print('\\r'+str(i),end='')",
        "    check(i)"
    ],
    "xref": [
        "Cf. A267939, A281555, A265737.",
        "A267939 is contained in the intersection of this sequence and A281555."
    ],
    "keyword": "nonn,base",
    "offset": "1,1",
    "author": "_David L. Reens_, Jun 01 2023",
    "references": 0,
    "revision": 23,
    "time": "2023-07-27T12:16:40-04:00",
    "created": "2023-07-27T12:16:40-04:00"
}