{
    "number": 306522,
    "data": "3,6,19,179,30176,1202267287",
    "name": "Number of simple directed cycles in the binary de Bruijn graphs of order n.",
    "comment": [
        "The numbers are computed empirically by the C++ program below. For n=7, the value is > 144*10^15 (the number of Hamiltonian cycles, A016031)."
    ],
    "example": [
        "For n=1, the cycles are (0), (1) and (0, 1).",
        "For n=2, they are (00), (00, 01, 10), (00, 01, 11, 10), (01, 10), (01, 11, 10), (11)."
    ],
    "program": [
        "(C++)",
        "#include <iostream>",
        "#include <vector>",
        "// DFS for binary de Bruijn graph. Count cycles starting at start, and",
        "// don't visit cycles with nodes v < start, to avoid double counting",
        "// any cycle.",
        "uint64_t cycles_visit(uint64_t mask, uint64_t start, uint64_t v, std::vector<char>& visited) {",
        "  visited[v] = true;",
        "  const uint64_t neighbors[2] = { (v << 1) & mask, ((v << 1) & mask) | 1 };",
        "  uint64_t count = 0;",
        "  for(uint64_t n : neighbors) {",
        "    if(n < start) continue;",
        "    if(visited[n]) {",
        "      if(n == start)",
        "        ++count;",
        "    } else {",
        "        count += cycles_visit(mask, start, n, visited);",
        "    }",
        "  }",
        "  visited[v] = false;",
        "  return count;",
        "}",
        "int main(int argc, char *argv[]) {",
        "  if(argc != 2) {",
        "    std::cerr << \"Usage: \" << argv[0] << \" k\\n\";",
        "    return 1;",
        "  }",
        "  const unsigned k = std::atoi(argv[1]);",
        "  const uint64_t mask = ((uint64_t)1 << k) - 1;",
        "  if(k == 1) { // Optimization below does not work for k==1",
        "    std::cout << 3 << '\\n';",
        "    return 0;",
        "  }",
        "  std::vector<char> visited(mask+1, false);",
        "  // Cycles starting with 0...01",
        "  uint64_t total = cycles_visit(mask, 1, 1, visited);",
        "  // Cycles containing  0...0 also contain 0...01, except for the self loop 0...0",
        "  total += total + 1;",
        "  // Start from all other nodes",
        "  for(uint64_t v = 2; v < mask; ++v) {",
        "    total += cycles_visit(mask, v, v, visited);",
        "  }",
        "  total += 1; // self loop 1...1",
        "  std::cout << total << '\\n';",
        "  return 0;",
        "}",
        "(Python)",
        "import networkx as nx",
        "def deBruijn(n): return nx.MultiDiGraph(((0, 0), (0, 0))) if n==0 else nx.line_graph(deBruijn(n-1))",
        "def A306522(n): return sum(1 for c in nx.simple_cycles(deBruijn(n))) # _Pontus von Br\u00f6mssen_, Jun 28 2021"
    ],
    "xref": [
        "Cf. A016031."
    ],
    "keyword": "nonn,hard,more",
    "offset": "1,1",
    "author": "_Guillaume Mar\u00e7ais_, Feb 21 2019",
    "references": 3,
    "revision": 21,
    "time": "2021-06-28T10:48:19-04:00",
    "created": "2019-03-02T11:56:50-05:00"
}