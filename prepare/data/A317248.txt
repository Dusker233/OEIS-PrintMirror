{
    "number": 317248,
    "data": "4,6,9,46,49,69,94,469,694,949,4694",
    "name": "Semiprimes which when truncated arbitrarily on either side in base 10 yield semiprimes.",
    "comment": [
        "There are exactly 3 1-digit terms, 4 2-digit terms, 3 3-digit terms, and 1 4-digit term.",
        "After the 4-digit term, there are no more terms in this sequence. This is provable by induction: There are no 5-digit terms. If there are no k-digit terms, there are no (k+1)-digit terms. (If there were, then said term, when truncated on either side, would produce a k-digit number that is in the sequence.) Therefore, there are no terms that have at least 5 digits.",
        "The sequence 3, 4, 3, 1, 0, 0, ... does not appear to be significant.",
        "This sequence depends on base 10 and is nonnegative.",
        "Any truncation of a number in this sequence yields another number in this sequence. If one did not, then truncating the number more would yield a non-semiprime, which is impossible.",
        "Base 10 is the first base in which this sequence contains 3-digit terms."
    ],
    "link": [
        "Keith J. Bauer, <a href=\"http://tpcg.io/cSo9J1\">\"A317248 (Python v2.7.13)\"</a>"
    ],
    "example": [
        "4694 is a semiprime (2 * 2347), and its truncations are, too: 469 (7 * 67), 694 (2 * 347), 46 (2 * 23), etc."
    ],
    "mathematica": [
        "ok[w_, n_] := AllTrue[Flatten@ Table[ FromDigits@ Take[w, {i, j}], {i, n}, {j, i, n}], PrimeOmega[#] == 2 &]; Union @@ Reap[ Do[Sow[ FromDigits /@ Select[Tuples[{4, 6, 9}, n], ok[#, n] &]], {n, 5}]][[2, 1]] (* _Giovanni Resta_, Jul 26 2018 *)"
    ],
    "program": [
        "(Python) #v2.7.13, see LINKS to run it online.",
        "#semitest(number, 0) returns True iff number is a semiprime",
        "def semitest(number, factors):",
        "    if number != 2:",
        "        for p in [2] + range(3, int(number ** 0.5) + 1, 2):",
        "            if number % p == 0:",
        "                if factors < 2:",
        "                    return semitest(number / p, factors + 1)",
        "                else:",
        "                    return False",
        "    if factors == 1:",
        "        return True",
        "    else:",
        "        return False",
        "#main function",
        "def doIt(base):",
        "    #initialization",
        "    numbers = [[]]",
        "    indices_list = [[]]",
        "    i = 0",
        "    for number in range(1, base):",
        "        if semitest(number, 0):",
        "            numbers[0].append(number)",
        "            indices_list[0].append([i])",
        "            i += 1",
        "    #numbers[0] is the digit pool",
        "    #numbers[-1] is to be appended to",
        "    #numbers[-2] is for reference to past numbers",
        "    #indices_list records the indices of numbers",
        "    numbers.append([])",
        "    indices_list.append([])",
        "    #main while loop, go until there are no numbers left in the sequence",
        "    indices = [0, 0]",
        "    while len(numbers[-2]) > 0:",
        "        #test number",
        "        if indices[:-1] in indices_list[-2]:",
        "            if indices[1:] in indices_list[-2]:",
        "                #little-endian",
        "                number = 0",
        "                power = 0",
        "                for index in indices:",
        "                    number += numbers[0][index] * base ** power",
        "                    power += 1",
        "                if semitest(number, 0):",
        "                    numbers[-1].append(number)",
        "                    indices_list[-1].append(indices[:])",
        "        #increment indices",
        "        for i in range(len(indices)):",
        "            indices[i] += 1",
        "            if indices[i] == len(numbers[0]):",
        "                indices[i] = 0",
        "                if i == len(indices) - 1:",
        "                    indices = [0] * len(indices) + [0]",
        "                    numbers.append([])",
        "                    indices_list.append([])",
        "            else:",
        "                break",
        "    #print results after while loop has run",
        "    print base, sum(numbers, [])",
        "    print numbers",
        "#call main function",
        "doIt(10)",
        "(Python)",
        "from sympy import factorint",
        "A317248_list = xlist = [4,6,9]",
        "for n in range(1,10):",
        "    ylist = []",
        "    for i in (4,6,9):",
        "        for x in xlist:",
        "            if sum(factorint(10*x+i).values()) == 2 and (10*x+i) % 10**n in xlist:",
        "                ylist.append(10*x+i)",
        "            elif sum(factorint(x+i*10**n).values()) == 2 and (x//10+i*10**(n-1)) in xlist:",
        "                ylist.append(x+i*10**n)",
        "    xlist = set(ylist)",
        "    if not len(xlist):",
        "        break",
        "    A317248_list.extend(xlist)",
        "A317248_list.sort() # _Chai Wah Wu_, Aug 23 2018"
    ],
    "xref": [
        "Cf. A001358.",
        "Subset of A107342 and A086698."
    ],
    "keyword": "base,fini,full,nonn",
    "offset": "1,1",
    "author": "_Keith J. Bauer_, Jul 24 2018",
    "references": 1,
    "revision": 27,
    "time": "2018-08-23T20:59:19-04:00",
    "created": "2018-08-23T17:09:35-04:00"
}