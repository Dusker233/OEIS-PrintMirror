{
    "number": 361530,
    "data": "23,37,53,73,113,127,131,137,139,151,157,173,179,193,197,211,223,229,233,239,241,271,283,293,311,313,317,331,337,347,353,359,367,373,379,383,389,397,421,431,433,457,523,541,547,571,593,613,617,631,673,677,719",
    "name": "Primes that can be written as the result of shuffling the decimal digits of two primes.",
    "comment": [
        "Each term is essentially an element of the shuffle product of the decimal digits of two primes (possibly equal)."
    ],
    "link": [
        "Michael S. Branicky, <a href=\"/A361530/b361530.txt\">Table of n, a(n) for n = 1..10000</a>",
        "John D. Cook, <a href=\"https://www.johndcook.com/blog/2023/03/13/shuffle-product/\">Shuffle product</a>.",
        "Wikipedia, <a href=\"https://en.wikipedia.org/wiki/Shuffle_algebra#Shuffle_product\">Shuffle product</a>."
    ],
    "example": [
        "37 and 73 are in the sequence because they are both the result of shuffling 3 and 7.",
        "127 is in the sequence because it is the result of shuffling 2 and the digits of 17.",
        "1193 is in the sequence because it is the result of shuffling the digits of 13 and the digits of 19.",
        "163 is not in the sequence because it is not the result of shuffling the digits of two primes. 163 is the result of permuting the digits of 3 and 61; however, 163 contains the digits of 61 in the wrong order."
    ],
    "program": [
        "(Python)",
        "import sympy",
        "def get_shuffle_product(list_1, list_2):",
        "    shuffle_product = set()",
        "    shuffle = []",
        "    _get_shuffle_product(list_1, list_2, shuffle, shuffle_product)",
        "    return shuffle_product",
        "def _get_shuffle_product(list_1, list_2, shuffle, shuffle_product):",
        "    if len(list_1) == 0 and len(list_2) == 0:",
        "        shuffle_product.add(tuple(shuffle))",
        "        return",
        "    else:",
        "        if len(list_1) == 0:",
        "            shuffle.append(list_2[0])",
        "            _get_shuffle_product(list_1, list_2[1:], shuffle, shuffle_product)",
        "            shuffle.pop()",
        "        elif len(list_2) == 0:",
        "            shuffle.append(list_1[0])",
        "            _get_shuffle_product(list_1[1:], list_2, shuffle, shuffle_product)",
        "            shuffle.pop()",
        "        else:",
        "            shuffle.append(list_1[0])",
        "            _get_shuffle_product(list_1[1:], list_2, shuffle, shuffle_product)",
        "            shuffle.pop()",
        "            shuffle.append(list_2[0])",
        "            _get_shuffle_product(list_1, list_2[1:], shuffle, shuffle_product)",
        "            shuffle.pop()",
        "max_prime_index = 25 # one and two digit primes.",
        "max_element = 999",
        "prime_set = set()",
        "for p_index in range(1, max_prime_index+1):",
        "    p = sympy.prime(p_index)",
        "    for q_index in range(p_index, max_prime_index+1):",
        "        q = sympy.prime(q_index)",
        "        list_p = list(str(p))",
        "        list_q = list(str(q))",
        "        shuffle_product = get_shuffle_product(list_p, list_q)",
        "        for s in shuffle_product:",
        "            candidate = int(''.join(s))",
        "            if sympy.isprime(candidate) and candidate <= max_element:",
        "                prime_set.add(candidate)",
        "print(sorted(prime_set))",
        "(Python)",
        "from sympy import isprime",
        "from itertools import chain, combinations",
        "def powerset(s): # skipping empty set and entire set",
        "    return chain.from_iterable(combinations(s, r) for r in range(1, len(s)))",
        "def ok(n):",
        "    if not isprime(n): return False",
        "    s = str(n)",
        "    for indices in powerset(range(len(s))):",
        "        t1 = \"\".join(s[i] for i in indices)",
        "        t2 = \"\".join(s[i] for i in range(len(s)) if i not in indices)",
        "        if t1[0] != \"0\" and t2[0] != \"0\" and isprime(int(t1)) and isprime(int(t2)):",
        "            return True",
        "print([k for k in range(720) if ok(k)]) # _Michael S. Branicky_, Apr 16 2023"
    ],
    "xref": [
        "Cf. A019549, A083427, A105184."
    ],
    "keyword": "nonn,base",
    "offset": "1,1",
    "author": "_Robert C. Lyons_, Mar 14 2023",
    "references": 1,
    "revision": 11,
    "time": "2023-04-16T09:48:04-04:00",
    "created": "2023-03-22T21:56:52-04:00"
}