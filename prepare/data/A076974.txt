{
    "number": 76974,
    "data": "2,3,7,13,19,25,31,39,43,49,55,61,69,73,81,85,91,99,103,109,115,123,129,133,139,147,151,159,165,169,175,181,187,193,199,207,213,225,229,235,241,253,259,265,271,279,283,291,295,309,313,319,333,337,349,355",
    "name": "Increasing sequence where each number is unequal to 2 mod all previous numbers.",
    "comment": [
        "Can be generated quickly by modified sieve of Eratosthenes. Note that eliminating numbers that equal zero mod any previous number is exactly the sieve of Eratosthenes and generates the primes; eliminating numbers that equal one mod any previous number just gives the even numbers.",
        "Bill McEachen has observed that, except for 5, this sequence contains the larger of every pair of twin primes (A006512). This is because the larger of a pair of twin primes could only be sieved out by the smaller twin in the same pair. But except for 3, the smaller twins are all 5 mod 6 and are sieved out by 3, so they are not present in the sequence and cannot sieve out the larger twins. - _David Eppstein_, Jul 20 2021"
    ],
    "link": [
        "Reinhard Zumkeller, <a href=\"/A076974/b076974.txt\">Table of n, a(n) for n = 1..10000</a>",
        "Nick MacKinnon, <a href=\"https://doi.org/10.2307/3618917\">Quasi-primes and the Goldbach conjecture</a>, Math. Gaz., 72 (1988), 103-108.",
        "<a href=\"/index/Si#sieve\">Index entries for sequences generated by sieves</a>"
    ],
    "example": [
        "a(4) = 13 because the smaller numbers after a(3) = 7 are eliminated: 8 == 2 (mod 2 or 3), 9 == 2 (mod 7), 10 == 2 (mod 2), 11 == 2 (mod 3), 12 == 2 (mod 2)."
    ],
    "program": [
        "(Python)",
        "def A076974():",
        "    D = {}",
        "    q = 2",
        "    while True:",
        "        if q not in D:",
        "            yield q",
        "            D.setdefault(q+2, []).append(q)",
        "        else:",
        "            for p in D[q]:",
        "                D.setdefault(p+q, []).append(p)",
        "            del D[q]",
        "        q += 1",
        "a = A076974(); print([next(a) for _ in range(100)])",
        "(Haskell)",
        "a076974 n = a076974_list !! (n-1)",
        "a076974_list = 2 : s [3, 5 ..] where",
        "   s (x:xs) = x : s [z | z <- xs, mod z x /= 2]",
        "-- _Reinhard Zumkeller_, Feb 28 2014"
    ],
    "xref": [
        "Cf. A006512."
    ],
    "keyword": "easy,nonn",
    "offset": "1,1",
    "author": "_David Eppstein_, Nov 28 2002",
    "ext": [
        "Offset changed by _Reinhard Zumkeller_, Feb 28 2014"
    ],
    "references": 3,
    "revision": 20,
    "time": "2023-03-18T03:20:31-04:00",
    "created": "2003-05-16T03:00:00-04:00"
}