{
    "number": 91511,
    "data": "1,1,30,5887172299,1025638889935309161425800069552344,11337715575060644543768059040620852798601554512475786008052416860406653219312996",
    "name": "Number of n X n X n 3-D matrices over symbol set {1,...,n} equivalent under any permutation of rows, columns, stacks or the symbol set.",
    "link": [
        "Philip Turecek, <a href=\"/A091511/b091511.txt\">Table of n, a(n) for n = 0..8</a>"
    ],
    "formula": [
        "a(n) = Sum_{1*s_1+2*s_2+...=n, 1*t_1+2*t_2+...=n, 1*u_1+2*u_2+...=n, 1*v_1+2*v_2+...=n} (fixA[s_1, s_2, ...;t_1, t_2, ...;u_1, u_2, ...;v_1, v_2, ...]/ (1^s_1*s_1!*2^s_2*s_2!*... *1^t_1*t_1!*2^t_2*t_2!*... *1^u_1*u_1!*2^u_2*u_2!*... *1^v_1*v_1!*2^v_2*v_2!*...)) where fixA[...] = Product_{i, j, k>=1} ( (Sum_{d|lcm(i, j, k)} (d*v_d))^(s_i*t_j*u_k *lcm(i, j, k)/(i*j*k))).",
        "a(n) asymptotic to n^(n^3)/(n!^4)."
    ],
    "program": [
        "(Sage)",
        "Pol.<x> = InfinitePolynomialRing(QQ)",
        "@cached_function",
        "def Z(n):",
        "    if n == 0: return Pol.one()",
        "    return sum(x[k]*Z(n-k) for k in (1..n))/n",
        "@cached_function",
        "def monprod(M):",
        "    p = Pol.one()",
        "    V = [m.variables() for m in M]",
        "    T = cartesian_product(V)",
        "    for t in T:",
        "        r = [Pol.varname_key(str(u))[1] for u in t]",
        "        j = [Pol(M[u[0]]).degree(u[1]) for u in enumerate(t)]",
        "        lcm_r = lcm(r)",
        "        p *= x[lcm_r]^(prod(r)/lcm_r*prod(j))",
        "    return p",
        "@cached_function",
        "def pol_isotop(n,k):",
        "    P = Z(n)",
        "    p = Pol.zero()",
        "    coeffs = P.coefficients()",
        "    mons = P.monomials()",
        "    C = cartesian_product(k*[mons])",
        "    Csorted = [tuple(sorted(u)) for u in C]",
        "    Cset = set(Csorted)",
        "    for c in Cset:",
        "        p += Csorted.count(c)*prod([coeffs[mons.index(u)] for u in c])*monprod(c)",
        "    return p",
        "@cached_function",
        "def rule_sub(r,m):",
        "    D = 0",
        "    for d in divisors(r):",
        "        try: D += d*m.degrees()[-d-1]",
        "        except: break",
        "    return D",
        "def a(n,k=3):",
        "    P = Z(n)",
        "    coeffs = P.coefficients()",
        "    Q = pol_isotop(n,k)",
        "    inds = [Pol.varname_key(str(u))[1] for u in Q.variables()]",
        "    p = 0",
        "    for mon in enumerate(P.monomials()):",
        "        m = Pol(mon[1])",
        "        p += coeffs[mon[0]]*Q.subs({x[i]:rule_sub(i,m) for i in inds})",
        "    return p",
        "# _Philip Turecek_, Jun 17 2023"
    ],
    "xref": [
        "Cf. A091058, A091510."
    ],
    "keyword": "nonn",
    "offset": "0,3",
    "author": "_Christian G. Bower_, Jan 16 2004",
    "ext": [
        "a(2) corrected by _Philip Turecek_, Jun 13 2023"
    ],
    "references": 2,
    "revision": 19,
    "time": "2023-07-27T12:17:39-04:00",
    "created": "2004-02-19T03:00:00-05:00"
}