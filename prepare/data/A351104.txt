{
    "number": 351104,
    "data": "1,12,28,98,386,943,1494,1680,2987,7083,57346,252548,331778,524289,596310,2886352,3247146,3264428,4585418,5158596,5772712,13019668,18341744,24455681,98041684,136696632,271114753,361486064,406672385,481981441,711611184,722067240",
    "name": "Numbers that begin a record-length run of consecutive numbers having the same Collatz trajectory length.",
    "comment": [
        "It appears that this sequence is infinite.",
        "For every record number of consecutive identical terms in A006577, the index of the first of those consecutive terms is a term of this sequence.",
        "This sequence is interesting because when A006577 is graphed on a scatter plot, it is immediately obvious that there are many runs of terms having the same value."
    ],
    "example": [
        "a(4)=98 since the length of the Collatz trajectory of each number from 98 through 102 is of length 25 and this is the fourth record length.",
        "From _Jon E. Schoenfield_, Feb 01 2022: (Start)",
        "      trajectory  numbers in run   run",
        "   n    length    (1st is a(n))   length",
        "  --  ----------  --------------  ------",
        "   1        1        1               1",
        "   2        9       12, 13           2",
        "   3       18       28, 29, 30       3",
        "   4       25       98 ...  102      5",
        "   5      120      386 ...  391      6",
        "   6       36      943 ...  949      7",
        "   7       47     1494 ... 1501      8",
        "   8       42     1680 ... 1688      9",
        "   9       48     2987 ... 3000     14",
        "  10       57     7083 ... 7099     17",
        "(End)"
    ],
    "program": [
        "(Python)",
        "import numpy as np",
        "def find_records(m):",
        "    l=np.array([0]+[-1 for i in range(m-1)])",
        "    for n in range(len(l)):",
        "        path=[n+1]",
        "        while path[-1]>m or l[path[-1]-1]==-1:",
        "            if path[-1]%2==0:",
        "                path.append(path[-1]//2)",
        "            else:",
        "                path.append(path[-1]*3+1)",
        "        path.reverse()",
        "        for i in range(1, len(path)):",
        "            if path[i]<=m:",
        "                l[path[i]-1]=l[path[0]-1]+i",
        "    ciclr=[]",
        "    c=1",
        "    lsteps=0",
        "    record=0",
        "    for n in range(1, len(l)):",
        "        if l[n]==lsteps:",
        "            c+=1",
        "        else:",
        "            if c>record:",
        "                record=c",
        "                ciclr.append(n-c+1)",
        "            c=1",
        "        lsteps=l[n]",
        "    return ciclr",
        "print(\", \".join([str(i) for i in find_records(1000000)]))"
    ],
    "xref": [
        "For length of run see A351224."
    ],
    "keyword": "nonn",
    "offset": "1,2",
    "author": "_Nathan John Eaves_, Jan 31 2022",
    "references": 1,
    "revision": 29,
    "time": "2022-03-09T00:40:20-05:00",
    "created": "2022-03-09T00:40:20-05:00"
}